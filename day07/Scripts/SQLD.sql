SELECT DISTINCT TBO.PRODUCT_ID
FROM TBL_ORDER TBO
JOIN TBL_PRODUCT TBP
ON TBO.PRODUCT_ID = TBP.ID;

-- 논리 연산자
SELECT *
FROM(
	SELECT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE 
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP
	ON TBO.PRODUCT_ID = TBP.ID 
)
WHERE PRODUCT_PRICE BETWEEN 100000 AND 300000;

-- IS NULL
-- IS NOT NULL : NULL이 아닌 데이터 조합
SELECT *
FROM(
	SELECT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE 
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP
	ON TBO.PRODUCT_ID = TBP.ID 
)
WHERE ORDER_END_DATE IS NOT NULL;

-- 문자열 함수
-- CONCAT(값, 값)
SELECT CONCAT('HELLO', 'WORLD')
FROM DUAL;

-- SUBSTR(): 문자열 추출
-- SUBSTRING() - MySQL문법
SELECT SUBSTR('오늘 점심 뭐 먹지?', 4, 2) FROM DUAL;

-- 더미 테이블 생성
CREATE SEQUENCE SEQ_SQLD_PRODUCT;
CREATE TABLE TBL_SQLD_PRODUCT(
	ID NUMBER CONSTRAINT PK_SQLD_PRODUCT PRIMARY KEY,
	SQLD_PRODUCT_NAME VARCHAR2(255),
	SQLD_PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);
INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);
INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '키보드', 20000);
INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '모니터', 20000);

CREATE SEQUENCE SEQ_SQLD_ORDER;
CREATE TABLE TBL_SQLD_ORDER(
	ID NUMBER CONSTRAINT PK_SQLD_ORDER PRIMARY KEY,
	SQLD_ORDER_NAME VARCHAR2(255),
	SQLD_PRODUCT_ID NUMBER,
	CONSTRAINT FK_SQLD_ORDER_SQLD_PRODUCT FOREIGN KEY(SQLD_PRODUCT_ID)
	REFERENCES TBL_SQLD_PRODUCT(ID)
);

INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 2)
INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 2)
INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 2)
INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 2)

-- 중복 연산자
-- 1) DISTINCT: 조회 결과의 중복을 제거한다
-- 2) UNION: 중복을 제거하고, 두 컬럼 데이터 조회를 합친다
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
UNION
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

-- 3) UNION ALL: 
-- 4) MINUS: 차집합
-- 5) INTERSECT ?
-- 6) 공집합

-- NULL 관련 연산자
-- 1) IS NULL: NULL이면 TRUE
-- 2) IS NOT NULL: NULL이 아니면 TRUE
---------------------------------------
-- 함수
---------------------------------------
-- 문자열 함수
-- UPPER(): 대문자로 변경
SELECT UPPER('hello') FROM DUAL;

-- LOWER(): 소문자로 변경
SELECT UPPER('DATING') FROM DUAL;

-- TRIM(): 공백제거
SELECT TRIM('  점 심 맛 있 게 먹 었 어 ? ') FROM DUAL;

-- REPLACE(): 특정 문자를 치환
SELECT REPLACE('  점 심 맛 있 게 먹 었 어 ? ', ' ', '') FROM DUAL;

-- INSTR(): 특정 문자열의 위치 반한
SELECT INSTR('강사님 질문해도 될까요?', '질문') FROM DUAL;

-- CURRENT_DATE: 현재 날짜
SELECT CURRENT_DATE FROM DUAL;

-- 현재 날짜를 기준으로 월을 추가
SELECT ADD_MONTHS(SYSDATE, 2) FROM DUAL;

-- 달 차이
-- MONTHS_BETWEEN()
SELECT MONTHS_BETWEEN(SYSDATE, '2024-07-12') FROM DUAL;

-- 일 차이
SELECT TO_DATE(SYSDATE) - TO_DATE('2024-07-12') FROM DUAL;

SELECT TO_TIMESTAMP(SYSDATE) - TO_TIMESTAMP('2024-07-12') FROM DUAL;

-- TRUNC(): 날짜의 시각을 제거하고 날짜만 반환
SELECT TRUNC(SYSDATE) FROM DUAL;

-- ABS(): 절댓값을 반환
SELECT ABS(-100) FROM DUAL;

-- CEIL(): 올림
SELECT CEIL(3.14) FROM DUAL;

-- FLOOR(): 내림
SELECT FLOOR(3.9) FROM DUAL;

-- MOD(): 나머지
SELECT MOD(5, 2) FROM DUAL;

-- ROUND(): 반올림
-- POWER(): 거듭제곱
SELECT POWER(2, 8) FROM DUAL;

-- 변환 함수
SELECT TO_NUMBER('123433.5') FROM DUAL;
SELECT TO_TIMESTAMP('2025-09-25 15:40:33', 'YYYY-MM-DD HH24:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;

-- SELECT TO_DATE()
SELECT CAST(10 AS VARCHAR(255)) FROM DUAL;
SELECT CAST('10.5' AS NUMBER) FROM DUAL;
SELECT CAST('2025-02-27' AS DATE) FROM DUAL;

-- ***** NULL 함수
-- NVL(): 첫 번째 값이 NULL이면 두 번째 값을 반환함
SELECT NVL(NULL, '대체 값') FROM NULL;

-- 삼항
-- NVL2(값1, 값2, 값3):
SELECT NVL2(10, 'TRUE', 'FALSE') FROM DUAL;

-- COALESCE(값1, 값2, 값3, 값4, ...): 값 중 NULL이 아닌 첫 번째 값을 반환
SELECT COALESCE(NULL, 2, NULL, 15) FROM DUAL;

-- NULLIF()
-- 두 값이 같으면 NULL, 아니라면 첫 번째 값
SELECT NULLIF(10, 15) FROM DUAL;

-- 조건식
-- IS NULL
-- IS NOT NULL


-- CASE문
SELECT
	CASE BUYER_GENDER
		WHEN '남' THEN '남성 고객'
		WHEN '여' THEN '여성 고객'
		ELSE '중성 고객'
	END 
FROM TBL_BUYER;

CREATE SEQUENCE SEQ_PRODUCT;
CREATE TABLE TBL_PRODUCT(
   ID NUMBER CONSTRAINT PK_PRODUCT PRIMARY KEY,
   PRODUCT_NAME VARCHAR2(255),
   PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 10000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 30000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 35000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 300000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 220000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 40000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 30000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 55000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 12000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 30000);

SELECT * FROM TBL_PRODUCT;

SELECT
	RANK() OVER(PARTITION BY PRODUCT_NAME ORDER BY PRODUCT_PRICE),
	PRODUCT_PRICE,
	PRODUCT_NAME,
	ROW_NUMBER() OVER(PARTITION BY PRODUCT_NAME ORDER BY PRODUCT_PRICE DESC) AS "AA",
	SUM(PRODUCT_PRICE) OVER(PARTITION BY PRODUCT_NAME)
FROM TBL_PRODUCT;

SELECT
	PRODUCT_PRICE,
	LEAD(PRODUCT_PRICE, 1) OVER(ORDER BY PRODUCT_PRICE) AS "LEAD",
	LAG(PRODUCT_PRICE, 1) OVER(ORDER BY PRODUCT_PRICE) AS "LAG",
	FIRST_VALUE(PRODUCT_PRICE) OVER(ORDER BY PRODUCT_PRICE) AS "FIRST VALUE",
	LAST_VALUE(PRODUCT_PRICE) OVER(
		ORDER BY PRODUCT_PRICE
		ROWS BETWEEN 1 PRECEDING AND 5 FOLLOWING
	) AS "LAST VALUE", 
	NTH_VALUE(PRODUCT_PRICE, 2) OVER(ORDER BY PRODUCT_PRICE) AS "NTH_VALUE",
	CUME_DIST() OVER(ORDER BY PRODUCT_PRISE) AS "CUME_DIST",
	PERCENT_RANK() OVER(ORDER BY PRODUCT_PRICE) AS "PERCENT_RANK" 
FROM TBL_PRODUCT;

-- 집계쿼리
SELECT
	PRODUCT_NAME,	
	PRODUCT_PRICE,
	SUM(PRODUCT_PRICE),
	COUNT(PRODUCT_PRICE)
FROM TBL_PRODUCT
GROUP BY ROLLUP(PRODUCT_NAME, PRODUCT_PRICE);